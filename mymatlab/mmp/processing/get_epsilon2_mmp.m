function [epsilon, pr_eps, w_eps]=get_epsilon2_mmp(drop);% Usage: [epsilon, pr_eps, w_eps]=get_epsilon2_mmp(drop);%   drop is the integer drop number%   testing is a string and must be 'y' to plot epsx (red +), epsy (green +),%      and epsilon (white line)%   epsilon is the average when neither  epsx nor  epsy are%      NaN and neither is more 4 times the other.  If one%      is more than 4 times the other, epsilon is the smaller.%   pr_eps is the pressure at the center of the epsilon window.% Function: to obtain the best estimate for epsilon from%    epsx and  epsy.% M.Gregg, 2 July 1995, rev. 28sep95% revised from get_eps1_amp to work for mmp.  J.Mackinnon 21 Aug 96testing='n';RATIO=4; % max allowable ratio between eps1 & eps2 for them to be averagedmmpfolderscruise=read_cruises_mmp(drop);% set up string names of files to open%fstr1=[procdata '\' cruise '\eps\eps' int2str(drop) '.mat'];%fstr2=[procdata '\' cruise '\problems\vx\badvx' int2str(drop) '.mat'];%fstr3=[procdata '\' cruise '\problems\vy\badvy' int2str(drop) '.mat'];fstr1=[procdata cruise filesep 'eps' filesep 'eps' int2str(drop) '.mat'];fstr2=[procdata cruise filesep 'problems' filesep 'vx' filesep 'badvx' int2str(drop) '.mat'];fstr3=[procdata cruise filesep 'problems' filesep 'vy' filesep 'badvy' int2str(drop) '.mat'];% load eps<drop>if exist(fstr1)~=2	nodata_str=['get_epsilon1_mmp: ' fstr1 ' does not exist'];	disp(nodata_str)else	ld_str=['load ' setstr(39) fstr1 setstr(39)];	eval(ld_str)  neps=length(pr_eps);	%mha change -- older files seem not to have eps1 and eps2	if ~exist('eps1')		eps1=epsilon(:,1);		eps2=epsilon(:,2);	end   epsx=eps1;  epsy=eps2;  % load badvx if it exists  if exist(fstr2)==2	  badvx_str=['load ' setstr(39) fstr2 setstr(39)];	  eval(badvx_str)  end  % load badvy if it exists  if exist(fstr3)==2	  badvy_str=['load ' setstr(39) fstr3 setstr(39)];	  eval(badvy_str)  end  % set up arrays for pr_lb & pr_ub of all eps bins if badvx or badvy  % exist  if exist('badvx')==1 | exist('badvy')==1	  pr_lb=zeros(size(pr_eps)); pr_ub=zeros(size(pr_eps));	  dpr=diff(pr_eps);	  pr_lb(1)=pr_eps(1)-dpr(1)/2;	  pr_lb(2:neps)=pr_eps(2:neps)-dpr(1:neps-1)/2;	  pr_ub(1:neps-1)=pr_eps(1:neps-1)+dpr(1:neps-1)/2;	  pr_ub(neps)=pr_eps(neps)+dpr(neps-1)/2;  end  % use badvx to set bad  epsx values to NaNs  if exist('badvx')==1	  sbvx=size(badvx);		  for i=1:sbvx(1)		  % find bins whose upper bounds exceed the lower bound		  % of the bad data		  iu=find(pr_ub>badvx(i,1));		  % find bins whose lower bounds are less than the lower 		  % bound of the bad data		  il=find(pr_lb<badvx(i,2));		  % find the indices common to iu and il		  imin=max(min(iu),min(il));		  imax=min(max(iu),max(il));		  epsx(imin:imax)=NaN*ones(1,imax-imin+1);	  end  end  % use badvy to set bad  epsy values to NaNs  if exist('badvy')==1	  sbvy=size(badvy);		  for i=1:sbvy(1)		  % find bins whose upper bounds exceed the lower bound		  % of the bad data		  iu=find(pr_ub>badvy(i,1));		  % find bins whose lower bounds are less than the lower 		  % bound of the bad data		  il=find(pr_lb<badvy(i,2));		  % find the indices common to iu and il		  imin=max(min(iu),min(il));		  imax=min(max(iu),max(il));		  epsy(imin:imax)=NaN*ones(1,imax-imin+1);	  end  end  % Take epsilon as the average of  epsx and  epsy.  If  epsx  % or  epsy is NaN, epsilon will be NaN.  epsilon=( epsx+ epsy)/2;  % If only  epsx or ep_vy is NaN, set epsilon to the good value  ix=find(~isnan( epsx)==1 & isnan( epsy)==1); % good vx & bad vy  epsilon(ix)= epsx(ix);  iy=find(isnan( epsx)==1 & ~isnan( epsy)==1); % good vy & bad vx  epsilon(iy)= epsx(iy);  % If  epsx &  epsy are not NaNs and one is more than RATIO  % times the other, take the lower assuming that the higher  % level was produced by a plankton impact.  i=find( epsx<RATIO* epsy);  epsilon(i)= epsx(i);  i=find( epsy<RATIO* epsx);  epsilon(i)= epsy(i);  % overlay epsilon profiles if testing  if strcmp(testing,'y')	  clf	  semilogx(epsilon,pr_eps,'w');	  set(gca,'ydir','reverse')	  hold on	  semilogx(epsx,pr_eps,'r+');	  semilogx(epsy,pr_eps,'g+');  endend